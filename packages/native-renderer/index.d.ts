/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** 单页渲染结果 */
export interface PageResult {
  /** 页码（从 1 开始） */
  pageNum: number
  /** 图像宽度 */
  width: number
  /** 图像高度 */
  height: number
  /** 编码后的图像数据 */
  buffer: Buffer
  /** 是否成功 */
  success: boolean
  /** 错误信息（如果失败） */
  error?: string
  /** 渲染耗时（毫秒） */
  renderTime: number
  /** 编码耗时（毫秒） */
  encodeTime: number
}
/** 原始位图结果（不编码） */
export interface RawBitmapResult {
  /** 是否成功 */
  success: boolean
  /** 错误信息（如果失败） */
  error?: string
  /** 图像宽度 */
  width: number
  /** 图像高度 */
  height: number
  /** 通道数（固定为 4，RGBA） */
  channels: number
  /** 原始 RGBA 像素数据 */
  buffer: Buffer
  /** 渲染耗时（毫秒） */
  renderTime: number
}
/** 批量渲染结果 */
export interface RenderResult {
  /** 是否成功 */
  success: boolean
  /** 错误信息（如果整体失败） */
  error?: string
  /** PDF 总页数 */
  numPages: number
  /** 每页的渲染结果 */
  pages: Array<PageResult>
  /** 总耗时（毫秒） */
  totalTime: number
}
/** 渲染配置选项 */
export interface RenderOptions {
  /** 目标渲染宽度（默认 1280） */
  targetWidth?: number
  /** 扫描件/图片页面的降级宽度（默认 1024） */
  imageHeavyWidth?: number
  /** 最大缩放比例（默认 4.0） */
  maxScale?: number
  /** 图片质量（1-100，用于 webp/jpg，已废弃，请使用 webp_quality/jpeg_quality） */
  quality?: number
  /** 是否启用扫描件检测（默认 true） */
  detectScan?: boolean
  /** 输出格式：webp, png, jpg（默认 webp） */
  format?: string
  /** WebP 编码质量（0-100，默认 80） */
  webpQuality?: number
  /** WebP 编码方法/速度（0-6，0最快，6最慢，默认 4） */
  webpMethod?: number
  /** JPEG 编码质量（0-100，默认 85） */
  jpegQuality?: number
  /** PNG 压缩级别（0-9，默认 6） */
  pngCompression?: number
}
/**
 * 从 PDF Buffer 渲染指定页面
 *
 * # Arguments
 * * `pdf_buffer` - PDF 文件的二进制数据
 * * `page_nums` - 要渲染的页码数组（从 1 开始）
 * * `options` - 渲染配置选项
 *
 * # Returns
 * 包含所有页面渲染结果的对象
 */
export declare function renderPages(pdfBuffer: Buffer, pageNums: Array<number>, options?: RenderOptions | undefined | null): RenderResult
/**
 * 从文件路径渲染 PDF 页面
 *
 * 直接从文件系统读取 PDF，避免在 Node.js 堆中创建大 Buffer。
 * 这是处理本地大文件的最高效方式。
 *
 * # Arguments
 * * `file_path` - PDF 文件的路径
 * * `page_nums` - 要渲染的页码数组（从 1 开始）
 * * `options` - 渲染配置选项
 *
 * # Returns
 * 包含所有页面渲染结果的对象
 */
export declare function renderPagesFromFile(filePath: string, pageNums: Array<number>, options?: RenderOptions | undefined | null): RenderResult
/**
 * 从文件路径获取 PDF 页数（不渲染）
 *
 * # Arguments
 * * `file_path` - PDF 文件的路径
 *
 * # Returns
 * PDF 的总页数
 */
export declare function getPageCountFromFile(filePath: string): number
/**
 * 获取 PDF 页数（不渲染）
 *
 * # Arguments
 * * `pdf_buffer` - PDF 文件的二进制数据
 *
 * # Returns
 * PDF 的总页数
 */
export declare function getPageCount(pdfBuffer: Buffer): number
/**
 * 渲染单页到原始位图（不编码）
 *
 * 这个函数只进行 PDFium 渲染，跳过图像编码步骤，
 * 返回原始 RGBA 像素数据。编码工作可以交给 Sharp 等更高效的库。
 *
 * # Arguments
 * * `file_path` - PDF 文件路径
 * * `page_num` - 页码（从 1 开始）
 * * `options` - 渲染选项
 *
 * # Returns
 * 包含原始位图数据和元信息的结果
 */
export declare function renderPageToRawBitmap(filePath: string, pageNum: number, options?: RenderOptions | undefined | null): RawBitmapResult
/** 从 Buffer 渲染单页到原始位图（不编码） */
export declare function renderPageToRawBitmapFromBuffer(pdfBuffer: Buffer, pageNum: number, options?: RenderOptions | undefined | null): RawBitmapResult
/** 检查 PDFium 库是否可用 */
export declare function isPdfiumAvailable(): boolean
/**
 * 预热 PDFium 库
 *
 * 在服务启动时调用，提前加载 PDFium 动态库并初始化，
 * 避免首次请求时的冷启动延迟（约 1-2 秒）
 *
 * # Returns
 * 预热耗时（毫秒）
 */
export declare function warmup(): number
/** 获取版本信息 */
export declare function getVersion(): string
/** 流式渲染结果（包含额外的统计信息） */
export interface StreamRenderResult {
  /** 是否成功 */
  success: boolean
  /** 错误信息（如果整体失败） */
  error?: string
  /** PDF 总页数 */
  numPages: number
  /** 每页的渲染结果 */
  pages: Array<PageResult>
  /** 总耗时（毫秒） */
  totalTime: number
  /** 流式加载统计 */
  streamStats?: StreamStats
}
/** 流式加载统计信息 */
export interface StreamStats {
  /** 总请求次数 */
  totalRequests: number
  /** 缓存命中次数 */
  cacheHits: number
  /** 缓存未命中次数 */
  cacheMisses: number
  /** 总下载字节数 */
  totalBytesFetched: number
}
/**
 * 从流式数据源渲染 PDF 页面（异步版本）
 *
 * 这个函数在独立线程中运行 PDFium 渲染，返回 Promise。
 * 主线程保持事件循环运行，可以处理 JS 回调。
 *
 * # Arguments
 * * `env` - NAPI 环境
 * * `pdf_size` - PDF 文件的总大小（字节）
 * * `page_nums` - 要渲染的页码数组（从 1 开始）
 * * `options` - 渲染配置选项
 * * `fetcher` - JavaScript 回调函数，用于获取指定范围的数据
 *
 * # Returns
 * Promise<StreamRenderResult>
 */
export declare function renderPagesFromStream(pdfSize: number, pageNums: number[], options: RenderOptions | null | undefined, fetcher: (offset: number, size: number, requestId: number) => void): object
/**
 * 完成流式请求
 *
 * 当 JS 端获取到数据后，调用这个函数将数据发送给 Rust 端。
 *
 * # Arguments
 * * `request_id` - 请求 ID
 * * `data` - 获取到的数据
 * * `error` - 错误信息（如果获取失败）
 */
export declare function completeStreamRequest(requestId: number, data?: Buffer | undefined | null, error?: string | undefined | null): void
